import{_ as t,r as d,o,c as p,e as a,a as n,b as s,d as c}from"./app-6e4b3321.js";const l={},r={href:"https://docs.github.com/cn/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue",target:"_blank",rel:"noopener noreferrer"};function u(g,e){const i=d("ExternalLinkIcon");return o(),p("div",null,[e[7]||(e[7]=a(`<p>当我们需要解决项目中的一个 bug 时，通常一个新的<code>PR</code>会伴随一个<code>issue</code>，本文将介绍仅需通过创建<code>PR</code>时一个操作，关联上<code>issue</code>，然后当<code>PR</code>被同意之后，对应关联的<code>issue</code>也将随之关闭。</p><p>同样，我先在示例项目中创建一个<code>issue</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220719_145415.png" alt="image_20220719_145415"></p><p>这种时候，作为项目维护者，我们可以直接点击<code>Development</code>中的 <code>Create a branch</code> 创建一个 fix 分支，这样会自动关联上这个<code>issue</code>，同理，当该 fix 分支创建的<code>PR</code>被合并之后，<code>issue</code>也会自动关闭。</p><p>不过这里不讲此种方案，大家有兴趣可以自行体验一番。</p><p>这里讲的是我们更常见的一种操作，在本地编辑器里，基于最新的<code>main分支</code>切出一个<code>fix</code>分支，如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout main
<span class="token function">git</span> pull
<span class="token function">git</span> checkout <span class="token parameter variable">-b</span> fix_testbug
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是在<code>fix_testbug</code>分支上进行对应问题的修复，这块儿不对赘述。</p><p>当我们感觉修复没问题了，也进行过自测了，就可以将此临时分支进行提交：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">&quot;fix: test bug&quot;</span>
<span class="token function">git</span> push --set-upstream origin fix_testbug
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>推到远程之后，我们来到 GitHub 页面中，此时可以看到 GitHub 会自动提示一个新的分支可以合并：</p><p><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220719_150429.png" alt="image_20220719_150429"></p><p>可以直接点击<code>Compare &amp; pull request</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220719_151051.png" alt="image_20220719_151051"></p>`,14)),n("p",null,[e[1]||(e[1]=s("注意右侧")),e[2]||(e[2]=n("code",null,"Development",-1)),e[3]||(e[3]=s("中的说明，我们可以通过在说明中添加一些")),n("a",r,[e[0]||(e[0]=s("关键字")),c(i)]),e[4]||(e[4]=s("，从而对")),e[5]||(e[5]=n("code",null,"issue",-1)),e[6]||(e[6]=s("进行关联，并触发关闭。当然也可以先创建 PR，然后再进行关联也可以："))]),e[8]||(e[8]=a(`<p><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220719_151313.png" alt="image_20220719_151313"></p><p>完成关联的 PR，可以看到有这样的状态显示：</p><p><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220719_151423.png" alt="image_20220719_151423"></p><p>这个时候，我们点击到<code>#21</code>号<code>issue</code>中，也可以看到被关联到该<code>PR</code>上了：</p><p><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220719_151547.png" alt="image_20220719_151547"></p><p>现在我们将 <code>#23</code> 号<code>PR</code>进行合并，合并之后可以看到关联的<code>issue</code>也被关闭了，此次关联的临时分支也被删除了：</p><p><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220719_151825.png" alt="image_20220719_151825"></p><p>以上就是项目协同中，<code>PR</code>与<code>issue</code>的联动维护。</p><hr><p><strong>另外：</strong> 这里插一个小点，当我们完成一次 PR 流程之后，作为项目主维护人，通常会再次切回到 main 分支，然后将远程被合并到 main 分支的代码拉到本地：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout main
<span class="token function">git</span> pull
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样执行之后，会发现本地代码竟然已经超过远程分支了：</p><p><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220719_154112.png" alt="image_20220719_154112"></p><p>其中的 389fe 那次是当前远程分支的 ID，我们可以执行如下命令，与远程对齐：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> origin/main
HEAD is now at 389fe7b fix: <span class="token builtin class-name">test</span> bug <span class="token punctuation">(</span><span class="token comment">#23)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样本地与远程就实现了对齐，在下次重新切分支，然后提交 PR 的时候，就不会出现上边那种，带了<code>几次Merge</code>的情况了。</p><p>图示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/eryajf/tu/img/image_20220719_154244.png" alt="image_20220719_154244"></p><p>理论上这次只有一个提交，而不应该出现 3 个<code>commit</code>，就是这个原因。</p>`,19))])}const v=t(l,[["render",u],["__file","04-PR-and-issue.html.vue"]]);export{v as default};
